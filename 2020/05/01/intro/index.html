<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="LGF">



    <meta name="description" content="技术、生活、分享">



<title>javascript高级程序设计学习 | 刘广飞的博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">刘广飞的个人博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">存档</a>
                
                    <a class="menu-item" href="/category">类别</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">刘广飞的个人博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">存档</a>
                
                    <a class="menu-item" href="/category">类别</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">javascript高级程序设计学习</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">LGF</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 1, 2020&nbsp;&nbsp;19:18:20</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="js高级程序设计学习笔记"><a href="#js高级程序设计学习笔记" class="headerlink" title="js高级程序设计学习笔记"></a>js高级程序设计学习笔记</h2><h3 id="DOM（Document-Object-Model）"><a href="#DOM（Document-Object-Model）" class="headerlink" title="DOM（Document Object Model）"></a>DOM（Document Object Model）</h3><p>是通过js可以重构整个html文档</p>
<p><strong>节点</strong>S</p>
<ol>
<li>整个文档是一个jiedian</li>
<li>每一个html标签是一个元素节点</li>
<li>包含在html元素中的文本是文本节点</li>
<li>每一个html属性是一个属性节点</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li><em>undefined<em>、</em>null<em>、</em>布尔<em>、</em>数字<em>、</em>字符串<em>、</em>对象<em>、</em>smybol<em>、</em>bigint</em></li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var message;</span><br><span class="line">alert(message &#x3D;&#x3D; undefined);  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<p>未初始化定义默认是<code>undefined</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(null &#x3D;&#x3D; undefined);  &#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F; null是从undefined派生</span><br><span class="line">alert(NaN &#x3D;&#x3D; NaN);  &#x2F;&#x2F;false</span><br><span class="line">&#x2F;&#x2F; not a number,很显然两个非数字不会相等</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>ECMAScript有两种数据类型<ul>
<li>基本数据类型，也就是<code>1</code>中的介绍</li>
<li>第二种是引用类型，因为js不允许直接访问内存中的位置，在操作对象时实际上是对操作对象的引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; new Object();</span><br><span class="line">var obj2 &#x3D; obj1;</span><br><span class="line">这里即obj2复制了一个指针（也是一种数据类型，不过是特殊的类型，用来存放堆中的对象地址），</span><br><span class="line">obj1的改变也会导致obj2的变化</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ol>
<li>全局作用域（window）</li>
<li>函数内部作用域</li>
</ol>
<p><strong>注意</strong><br>js本身无块级作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(true) &#123;</span><br><span class="line">  var color &#x3D; &quot;red&quot;</span><br><span class="line">&#125;</span><br><span class="line">alert(color); &#x2F;&#x2F;red</span><br></pre></td></tr></table></figure>
<ul>
<li>这里就是全局作用域，</li>
<li>如果是C、Java，color会在if结束后销毁</li>
<li>{}是块级作用域</li>
</ul>
<h3 id="Array队列"><a href="#Array队列" class="headerlink" title="Array队列"></a>Array队列</h3><p><code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>reverse()</code>、<code>sort()</code>、<code>concat()</code>、<code>slice()</code>、<code>splice()</code><br><code>indexOf()</code>、<code>lastIndexOf()</code>、<code>fliter()</code>、<code>map()</code>、<code>reduce</code></p>
<h3 id="Function函数"><a href="#Function函数" class="headerlink" title="Function函数"></a>Function函数</h3><p>在js中函数名只是指向函数的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum1(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">var sum2 &#x3D; sum1;</span><br><span class="line">alert(sum2(1, 2));  &#x2F;&#x2F;3</span><br><span class="line">sum1 &#x3D; null;</span><br><span class="line">alert(sum2(1, 2));  &#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>

<p><strong>函数内部参数</strong><br>函数内部有<code>arguments</code>和<code>this</code>，而<code>arguments</code>还有<code>callee</code>属性，<code>callee</code>是一个指针，指向了拥有这个<br><code>arguments</code>对象的函数，换句话说是一个指向正在执行的函数的指针</p>
<blockquote>
<p>递归被多个地方调用而不干扰的方式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum (n) &#123;</span><br><span class="line">  if(n&lt;&#x3D;1) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return n*arguments.callee(n-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数的属性和方法</strong><br><code>length</code>：传递参数的个数<br><code>prototype</code><br><code>apply()</code>、<code>call()</code>是每个函数都有非继承而来的方法。<br>实际上等于设置函数内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，<br>另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2)&#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum1(num1, num2)&#123;</span><br><span class="line">  return sum.apply(this, arguments); &#x2F;&#x2F; 传入arguments 对象，在apply和call中，this一般指代window</span><br><span class="line">&#125;</span><br><span class="line">function callSum2(num1, num2)&#123;</span><br><span class="line">  return sum.apply(this, [num1, num2]); &#x2F;&#x2F; 传入数组</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum1(10,10)); &#x2F;&#x2F;20</span><br><span class="line">alert(callSum2(10,10)); &#x2F;&#x2F;20</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，callSum1()在执行sum()函数时传入了this 作为this 值（因为是在全局<br>作用域中调用的，所以传入的就是window 对象）和arguments 对象。而callSum2 同样也调用了<br>sum()函数，但它传入的则是this 和一个参数数组。这两个函数都会正常执行并返回正确的结果。<br>call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()<br>方法而言，第一个参数是this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用<br>call()方法时，传递给函数的参数必须逐个列举出来。</p>
<blockquote>
<p>事实上，传递参数并非apply()和call()真正的用武之地；真正强大的地方是能够扩充函数赖以运行的作用域。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.color &#x3D; &quot;red&quot;;</span><br><span class="line">var o &#x3D; &#123;color: &quot;blue&quot;&#125;</span><br><span class="line"></span><br><span class="line">function sayColor() &#123;</span><br><span class="line">  alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor();</span><br><span class="line">sayColor.call(this);</span><br><span class="line">sayColor.call(window);</span><br><span class="line">sayColor.call(o);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>match</code>、<code>search</code>、<code>split</code>、<code>replace</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; &quot;cat, bat, sat, fat&quot;;</span><br><span class="line">var result &#x3D; text.replace(&quot;at&quot;, &quot;ond&quot;);</span><br><span class="line">alert(result); &#x2F;&#x2F;&quot;cond, bat, sat, fat&quot;</span><br><span class="line">result &#x3D; text.replace(&#x2F;at&#x2F;g, &quot;ond&quot;);</span><br><span class="line">aler t(result); &#x2F;&#x2F;&quot;cond, bond, sond, fond&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>EXMAScript中最为强大的一个方法，eval()<br><code>eval(&quot;alert(&#39;hi&#39;)&quot;);</code><br>这行代码的作用等价于下面这行代码：<br><code>alert(&quot;hi&quot;);</code><br>当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript 语句来解析，<br>然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，<br>因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包<br>含环境中定义的变量，举个例子：<br><code>var msg = &quot;hello world&quot;;</code><br><code>eval(&quot;alert(msg)&quot;); //&quot;hello world&quot;</code><br>可见，变量msg 是在eval()调用的环境之外定义的，但其中调用的alert()仍然能够显示”hello<br>world”。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在eval()<br>调用中定义一个函数，然后再在该调用的外部代码中引用这个函数：<br><code>eval(&quot;function sayHi() { alert(&#39;hi&#39;); }&quot;);</code><br><code>sayHi();</code></p>
</blockquote>
<blockquote>
<p>Math<br><code>Math.min()</code>、<code>Math.max()</code>、<code>Math.ceil()</code>、<code>Math.floor()</code>、<code>Math.round()</code>、<code>Math.random()</code></p>
</blockquote>
<h3 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h3><p><strong>属性类型</strong></p>
<blockquote>
<p>属性类型》数据属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[Configurable]]：布尔值，表示能否删除属性，默认是true</span><br><span class="line">[[Enumerable]]：布尔值，表示能否通过for-in循环返回属性，默认是true</span><br><span class="line">[[Writable]]：布尔值，表示能否修改属性的值，默认是true</span><br><span class="line">[[Value]]：包含这个属性的数据值，默认是undefined</span><br></pre></td></tr></table></figure>
<p>如果要修改一个默认属性，需要使用<code>Object.defineProperty()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class="line">  writable: false,</span><br><span class="line">  value: &quot;Nicholas&quot;</span><br><span class="line">&#125;);</span><br><span class="line">alert(person.name); &#x2F;&#x2F;&quot;Nicholas&quot;</span><br><span class="line">person.name &#x3D; &quot;Greg&quot;;</span><br><span class="line">alert(person.name); &#x2F;&#x2F;&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>属性类型》访问器属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[Configurable]]：布尔值，表示能否删除属性，默认是true</span><br><span class="line">[[Enumerable]]：布尔值，表示能否通过for-in循环返回属性，默认是true</span><br><span class="line">[[Get]]：在读取属性时调用的函数。默认值为undefined。</span><br><span class="line">[[Set]]：在写入属性时调用的函数。默认值为undefined。</span><br></pre></td></tr></table></figure>
<p>访问器属性不能直接定义，必须使用<code>Object.defineProperty()</code>来定义。请看下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var book &#x3D; &#123;</span><br><span class="line">  _year: 2004,</span><br><span class="line">  edition: 1</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book, &quot;year&quot;, &#123;</span><br><span class="line">  get: function()&#123;</span><br><span class="line">    return this._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function(newValue)&#123;</span><br><span class="line">    if (newValue &gt; 2004) &#123;</span><br><span class="line">      this._year &#x3D; newValue;</span><br><span class="line">      this.edition +&#x3D; newValue - 2004;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year &#x3D; 2005;</span><br><span class="line">alert(book.edition); &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>
<p><strong>创建对象</strong></p>
<blockquote>
<p>创建对象 》 工厂模式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name, age, job)&#123;</span><br><span class="line">  var o &#x3D; new Object();</span><br><span class="line">  o.name &#x3D; name;</span><br><span class="line">  o.age &#x3D; age;</span><br><span class="line">  o.job &#x3D; job;</span><br><span class="line">  o.sayName &#x3D; function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 &#x3D; createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建对象 》 构造函数模式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.job &#x3D; job;</span><br><span class="line">  this.sayName &#x3D; function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; new Person(&quot;Nicholas&quot;, 29, &quot;SoftwareEngineer&quot;);</span><br><span class="line">var person2 &#x3D; new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br></pre></td></tr></table></figure>
<p>对比工厂模式，</p>
<ol>
<li>没有显式的创建对象</li>
<li>直接将属性和方法赋给了this对象</li>
<li>没有return语句</li>
<li>还应该注意到函数名Person 使用的是大写字母P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构<br>造函数则应该以一个小写字母开头<br>创建过程<br>要创建Person 的新实例，必须使用new 操作符，并且会经历以下4个步骤<br>(1) 创建一个新对象<br>(2) 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）<br>(3) 执行构造函数中的代码（为这个新对象添加属性）<br>(4) 返回一个新对象</li>
<li>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不<br>存在定义构造函数的特殊语法。任何函数，只要通过new 操作符来调用，那它就可以作为构造函数；而<br>任何函数，如果不通过new 操作符来调用，那它就是普通函数<br>例如前面的Person()函数，可以用以下方式调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当作构造函数使用</span><br><span class="line">var person &#x3D; new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">person.sayName(); &#x2F;&#x2F;&quot;Nicholas&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 作为普通函数调用</span><br><span class="line">&#x2F;&#x2F; 当在全局作用域中调用一个函数时，this 对象总是指向Global 对象（在浏览器中就是window 对象</span><br><span class="line">Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); &#x2F;&#x2F; 添加到window</span><br><span class="line">window.sayName(); &#x2F;&#x2F;&quot;Greg&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在另一个对象的作用域中调用</span><br><span class="line">&#x2F;&#x2F; call（或者apply） 可以扩展函数的作用域，将this替换成new的对象</span><br><span class="line">&#x2F;&#x2F; 这里是在对象o 的作用域中调用的，因此调用后o 就拥有了所有属性和sayName()方法</span><br><span class="line">var o &#x3D; new Object();</span><br><span class="line">Person.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;);</span><br><span class="line">o.sayName(); &#x2F;&#x2F;&quot;Kristen&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>原型模式<br>创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，<br>而使用原型对象可以让所有对象实例共享它所包含的属性和方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name &#x3D; &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age &#x3D; 29;</span><br><span class="line">Person.prototype.job &#x3D; &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName &#x3D; function()&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 &#x3D; new Person();</span><br><span class="line">person1.sayName(); &#x2F;&#x2F;&quot;Nicholas&quot;</span><br><span class="line">var person2 &#x3D; new Person();</span><br><span class="line">person2.sayName(); &#x2F;&#x2F;&quot;Nicholas&quot;</span><br><span class="line">alert(person1.sayName &#x3D;&#x3D; person2.sayName); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>组合使用构造函数模式和原型模式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.job &#x3D; job;</span><br><span class="line">  this.friends &#x3D; [&quot;Shelby&quot;, &quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">  constructor : Person,</span><br><span class="line">  sayName : function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 &#x3D; new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends); &#x2F;&#x2F;&quot;Shelby,Count,Van&quot;</span><br><span class="line">alert(person2.friends); &#x2F;&#x2F;&quot;Shelby,Count&quot;</span><br><span class="line">alert(person1.friends &#x3D;&#x3D;&#x3D; person2.friends); &#x2F;&#x2F;false</span><br><span class="line">alert(person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p><strong>继承</strong></p>
<ol>
<li>原型链<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">  this.property &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;继承了SuperType</span><br><span class="line">SubType.prototype &#x3D; new SuperType();</span><br></pre></td></tr></table></figure></li>
<li>借用构造函数（经典继承）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">  this.colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">  &#x2F;&#x2F;继承了SuperType</span><br><span class="line">  SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line">var instance1 &#x3D; new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors); &#x2F;&#x2F;&quot;red,blue,green,black&quot;</span><br><span class="line">var instance2 &#x3D; new SubType();</span><br><span class="line">alert(instance2.colors); &#x2F;&#x2F;&quot;red,blue,green&quot;</span><br></pre></td></tr></table></figure>
通过使用call()方法（或apply()方法也可以），我们实际上是在（未来将要）新创建的SubType 实例的环境下调用了SuperType 构造函数。这样一来，就会在新SubType 对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的colors 属性的副本了。</li>
<li>原型式继承</li>
<li>寄生式继承</li>
</ol>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><blockquote>
<p>定义函数的方式有两种，函数声明和函数表达式。<br>函数声明有个很重要的特征是函数声明提升，意思是在执行代码之前会先读取函数声明<br>意味着函数声明可以放在调用它的语句后面，如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line">function sayHi()&#123;</span><br><span class="line">  alert(&quot;Hi!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var functionName &#x3D; function(arg0, arg1) &#123;</span><br><span class="line">  &#x2F;&#x2F; 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数表达式来定义，按照上面函数声明的方式来调用函数会报错</p>
<blockquote>
<p>递归</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">三种方式对比：</span><br><span class="line">function factorial(num) &#123;</span><br><span class="line">  if(num &lt;&#x3D; 1) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return num * factorial(num-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">  if (num &lt;&#x3D; 1)&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return num * arguments.callee(num-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var factorial &#x3D; (function f(num)&#123;</span><br><span class="line">  if (num &lt;&#x3D; 1)&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return num * f(num-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>闭包<br>创建闭包最常见的方式就是在一个函数内部创建另一个函数，并return这个内部函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">函数执行环境-&gt;作用域链-&gt;全局变量对象</span><br><span class="line">                    -&gt;函数的活动对象</span><br><span class="line"></span><br><span class="line">全局环境的变量对象始终存在，而像</span><br><span class="line">compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数</span><br><span class="line">时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。</span><br><span class="line">当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对</span><br><span class="line">象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执</span><br><span class="line">行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变</span><br><span class="line">量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只</span><br><span class="line">引用但不实际包含变量对象。</span><br><span class="line">无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，</span><br><span class="line">当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。</span><br><span class="line">但是，闭包的情况又有所不同。</span><br><span class="line">函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换</span><br><span class="line">句话说，当函数执行后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>闭包 》 this<br>this 对象是在运行时基于函数的执行环境绑定的：在全局函数中，this 等于window，<br>而当函数被作为某个对象的方法调用时，this 等于那个对象，不过，匿名函数的执行环境具有全局性，因此其this 对象通常指向window。</p>
</blockquote>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型 window</p>
<blockquote>
<p>location</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.location.hash</span><br><span class="line">window.location.href</span><br><span class="line">window.location.search</span><br><span class="line">window.location.pathname</span><br></pre></td></tr></table></figure>
<blockquote>
<p>history</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.go(-1)</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><blockquote>
<p>Mizilla (Mosaic killer)<br>内核webkit、ie、gecko、khtml、opera<br><strong>判断浏览器内核</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义对象管理浏览器内核</span><br><span class="line">var client &#x3D; function()&#123;</span><br><span class="line">  var engine &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;呈现引擎</span><br><span class="line">    ie: 0,</span><br><span class="line">    gecko: 0,</span><br><span class="line">    webkit: 0,</span><br><span class="line">    khtml: 0,</span><br><span class="line">    opera: 0,</span><br><span class="line">    &#x2F;&#x2F;具体的版本号</span><br><span class="line">    ver: null</span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;&#x2F;在此检测呈现引擎、平台和设备</span><br><span class="line">  return &#123;</span><br><span class="line">    engine : engine</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">var ua &#x3D; navigator.userAgent;</span><br><span class="line">if (window.opera)&#123;</span><br><span class="line">  engine.ver &#x3D; window.opera.version();</span><br><span class="line">  engine.opera &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125; else if (&#x2F;AppleWebKit\&#x2F;(\S+)&#x2F;.test(ua))&#123;</span><br><span class="line">  engine.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">  engine.webkit &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125; else if (&#x2F;KHTML\&#x2F;(\S+)&#x2F;.test(ua)) &#123;</span><br><span class="line">  engine.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">  engine.khtml &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125; else if (&#x2F;rv:([^\)]+)\) Gecko\&#x2F;\d&#123;8&#125;&#x2F;.test(ua))&#123;</span><br><span class="line">  engine.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">  engine.gecko &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125; else if (&#x2F;MSIE ([^;]+)&#x2F;.test(ua))&#123;</span><br><span class="line">  engine.ver &#x3D; RegExp[&quot;$1&quot;];</span><br><span class="line">  engine.ie &#x3D; parseFloat(engine.ver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断平台</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.platform</span><br></pre></td></tr></table></figure>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>LGF</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://troysjphp.github.io/2020/05/01/intro/">https://troysjphp.github.io/2020/05/01/intro/</a></span>
                    </p>
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span><strong>talk is cheap, show me the code</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/javascript/"># javascript</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/11/11/intro/">javascript学习笔记</a>
            
            
            <a class="next" rel="next" href="/2020/04/28/intro/">javascript的面试总结（part2）</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© LGF | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
